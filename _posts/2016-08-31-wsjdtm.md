---
layout: post
title:  "Parsing DTMs from the Wall Street Journal"
date:   2016-08-31
categories: post
---

A longstanding interest of mine is how investors respond to political instability -- like news of corruption scandals, gridlock, etc. Since the Wall Street Journal is a good financial newspaper of record, I'm wondering if the content of WSJ articles can help predict fluctuations in bonds and equities, when combined with monthly economic indicators like industrial production, building permits, etc. 

As a first step towards finding out, I wanted to make a script to web-scrape WSJ articles about a given country to create a document term matrix (DTM). Since the WSJ is a dynamic site, we're going to have to use `selenium` here. 

Start by importing a whole bunch of `selenium` bells and whistles, along with standard ML stuff and some processing tools from `nltk`. 

{% highlight python %}
import os, re, csv, nltk, datetime
import pandas as pd
import numpy as np

from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

from urllib.request import urlopen
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from unidecode import unidecode

#  Import stemmers and dictionaries for stop words
snowball = nltk.stem.SnowballStemmer('english')
lancaster = nltk.stem.LancasterStemmer()
stop_words = urlopen('http://jmlr.org/papers/volume5/lewis04a/a11-smart-stop-list/english.stop').read().decode("utf-8").split("\n")
stop_words = set(stop_words)

{% endhighlight %}

We'll also borrow a function from <a href = "https://github.com/andrewzc/python-wsj">andrewcz</a> to help extract URLs as string from html `<a>` tags. (More on this later.) The start of Andrew's script is useful for getting acquainted with `selenium` but we'll have to go farther if we want to create DTMs for thousands of articles in a robust way.
{% highlight python %}
def getPageUrl(elementLinks):
    extractLinks = []
    for element in elementLinks:
        links = element.get_attribute('href')
        extractLinks.append(links)
    return(extractLinks)
{% endhighlight %}

To start we'll bring up the WSJ in Firefox - and I'll enter my login credentials in the placeholders `your_username` and `your_password` 

{% highlight python %}
# Loading home URL
browser = webdriver.Firefox()
browser.get('http://markets.wsj.com/?mod=Homecle_MDW_MDC')

# Login Credentials
login = browser.find_element_by_link_text("Log In").click()
loginID = browser.find_element_by_id("username").send_keys('your_username')
loginPass = browser.find_element_by_id("password").send_keys('your_password')
loginReady = browser.find_element_by_class_name("login_submit")
loginReady.submit()

{% endhighlight %}

Now that we're logged in, let's choose a country and start scraping articles about it. In our example, we'll use Malaysia, which has been the subject of a lot of interesting news over the past few years, including the 1MDB scandal and the tragic disappearance of Malaysian Airlines flight 370. Remember that we've just logged in with our credentials, so to make sure we can input search terms without the code crashing, we'll need to first invoke a wait command. Here, we're giving the page 10 seconds to load before we try to locate the search box. Once we've found it, we can enter the word 'Malaysia' into the search box through our Python script. 

{% highlight python %}

## Basic search: articles containing Malaysia 
WebDriverWait(browser, 10).until(
        EC.presence_of_element_located((By.ID, "globalHatSearchInput"))
    )

search_box = browser.find_element_by_id("globalHatSearchInput")
search_box.clear()
search_box.send_keys('Malaysia') # Input search keyword
WebDriverWait(browser, 3)
search_req = browser.find_element_by_css_selector('.button-search').click()

{% endhighlight %}

If you're using Firefox (as opposed to Chrome), there will be an annoying cookies disclaimer banner that interferes with further scraping until you close it. So let's take care of that:

{% highlight python %}

## Close cookie policy if needed
try:
    browser.find_element_by_class_name("close").click()
except NoSuchElementException:
    print('Cookie agreement already acknowledged')
    
{% endhighlight %}

Next, let's narrow our search a bit. In particular, we can focus on a specific date range and also isolate articles whose subject is Malaysia. The code here is finding the ADVANCED SEARCH link, clicking it, inputting dates, putting `Malaysia` in the Keywords box, and excluding all manner of videos, blogs etc. These are less traditional forms of media and also more difficult to scrape (although future versions of this project could try to incorporate these, too). 

{% highlight python %}
## Expand ADVANCED SEARCH and enter a date range. 
toggleMenu = browser.find_element_by_link_text("ADVANCED SEARCH")
toggleMenu.click()
menuOptions = browser.find_element_by_class_name('datePeriod')
browser.find_element_by_name("sfrom").send_keys("2014/08/25")
browser.find_element_by_name("sto").send_keys("2016/08/25")

## Restrict search to articles whose subject is the country:
browser.find_element_by_id('metadata').send_keys("Malaysia")

## Restrict search to articles only (exclude videos, blogs, etc)
browser.execute_script("window.scrollTo(0, 500)")
browser.find_element_by_link_text("WSJ Blogs").click()
browser.find_element_by_link_text("WSJ Videos").click()
browser.find_element_by_link_text("WSJ Site Search").click()

## Scroll up to the search button and click
browser.execute_script("window.scrollTo(0, 0)")
searchArchive = browser.find_element_by_class_name('keywordSearchBar')
searchArchive.find_element_by_class_name("searchButton").click()

{% endhighlight %} 

If you're following along, this should give you page 1 of 38 pages of search results -- and there should be 758 of them. We'll want to keep track of these numbers when extracting URLs from the search results, so let's define them as variables:

{% highlight python %}
pageCount = browser.find_elements_by_class_name("results-count")[1].text
pageCount = int(re.sub(r'of ', '', pageCount))
pageCount 
# 38

resultCount = browser.find_elements_by_class_name("results-count")[0].text
resultCount = int(resultCount.rpartition("of ")[2])
resultCount
# 758
{% endhighlight %}




