---
layout: post
title:  "Computing Risk Neutral Distributions from Option Prices in R"
date:   2016-05-15
---

This post gives some R code to replicate a <a href = "https://www.newyorkfed.org/medialibrary/media/research/staff_reports/sr677.pdf">2014 paper</a> by Allan Malz, essentially a cookbook for computing risk-neutral distributions from option prices. These distributions give us a sense of investors' expected beliefs about future asset prices (assuming investors are close enough to being risk neutral). The below example relies on [a panel of option prices on USDBRL]({{ base.url }}/assets/OptPanel.csv).

<!--more-->

Load the requisite libraries and data. 

{% highlight r %}
library("openxlsx")
library("zoo")
library("fOptions")
library("pracma")
library("lubridate")
library("reshape")
library("TTR")

p <- read.csv("OptPanel.csv", header = T)
p$dts <- as.Date(p$dts, format = "%Y-%m-%d")
p <- zoo(p[,2:ncol(p)], order.by = p$dts)
head(p)
            rr10    rr25   bf10  bf25   S      F      r      q
2009-11-17 10.6500 5.8450 2.680 1.000 1.7117 1.7224  3.766 0.275
2009-11-18 10.7600 5.8225 2.910 1.000 1.7255 1.7372 10.768 0.230
2009-11-19 10.2800 5.6000 2.825 0.970 1.7268 1.7380  7.895 0.275
2009-11-20 10.2275 5.5850 2.795 0.970 1.7314 1.7422  4.153 0.275
2009-11-23  9.7900 5.3800 2.590 0.935 1.7265 1.7374  7.211 0.275
2009-11-24  9.7925 5.3575 2.660 0.945 1.7313 1.7403  5.546 0.275
{% endhighlight %}

Variables are as follows:

**rr10** price of a 90-10 3m risk reversal\\
**r25** price of a 75-25 3m risk reversal\\
**bf10** price of a 90-10 3m butterfly\\
**bf25** price of a 75-25 3m butterfly\\
**S** USDBRL spot\\
**F** USDBRL 3m forward\\
**r** Brazil policy rate\\
**q** US policy rate\\

The first step in computing (more like imputing...) risk-neutral distributions is to use listed option prices to back out implied volatiles at different values of delta. We can wrap this process into a `GetVolatilities()` function. 

{% highlight r %}
GetVolatilities <- function(p){
	# Args:
	# -----
	# Data.frame with variables
	# date dts; option prices rr10, rr25, bf10, bf25; interest rates r and q
	#
	# Returns:
	# ---------
	# Data.frame with 10, 25, 50, 75, 90 call delta volatilities

	## Back out ATM volatility
	atm.SS <- function(atm){
		lhs <- 0.5
		rhs <- GBSGreeks(Selection = "delta", TypeFlag = "c", S = S, X = X,
	                  Time = 1/12, r = r/100, b = (r - q)/100, sigma = atm)
		return( (lhs-rhs)^2 )
	}

	p$atm <- rep(NA, nrow(p))
	for(i in 1:nrow(p)){
		S = as.numeric(p$S[i])
		X = as.numeric(p$F[i])
		r = as.numeric(p$r[i])
		q = as.numeric(p$q[i])
		p$atm[i] <- 100*optimize(atm.SS, interval = c(0, 2))$minimum
	}

	## Get volatilities from RR, BF and ATM data:
	p$sig25 <- p$atm + p$bf25 + 0.5*p$rr25
	p$sig75 <- p$atm + p$bf25 - 0.5*p$rr25
	p$sig10 <- p$atm + p$bf10 + 0.5*p$rr10
	p$sig90 <- p$atm + p$bf10 - 0.5*p$rr10

	return(p)

}

head(p)
             rr10   rr25  bf10  bf25    S      F      r      q     atm       sig25      sig75    sig10     sig90
2009-11-17 10.6500 5.8450 2.680 1.000 1.7117 1.7224  3.766 0.275 28.338350 32.260850 26.415850 36.34335 25.693350
2009-11-18 10.7600 5.8225 2.910 1.000 1.7255 1.7372 10.768 0.230 22.041991 25.953241 20.130741 30.33199 19.571991
2009-11-19 10.2800 5.6000 2.825 0.970 1.7268 1.7380  7.895 0.275  5.353995  9.123995  3.523995 13.31900  3.038995
2009-11-20 10.2275 5.5850 2.795 0.970 1.7314 1.7422  4.153 0.275 26.872811 30.635311 25.050311 34.78156 24.554061
2009-11-23  9.7900 5.3800 2.590 0.935 1.7265 1.7374  7.211 0.275 11.200694 14.825694  9.445694 18.68569  8.895694
2009-11-24  9.7925 5.3575 2.660 0.945 1.7313 1.7403  5.546 0.275 13.892116 17.515866 12.158366 21.44837 11.655866

{% endhighlight %}

We can then interpolate a cubic spline through these (delta, ivol) pairs using a function `DeltaSmile()` and plot the smile using `PlotDeltaSmile()`:
{% highlight r %}
DeltaSmile <- function(delta, dtStart){
	# Args:
	# -----
	# date dts, delta input value
	#
	# Returns:
	# --------
	# value of interpolated implied vol for given delta

	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	x <- c(0.1, 0.25, 0.5, 0.75, 0.9)
	y <- c(as.numeric(p$sig10[i]), as.numeric(p$sig25[i]), as.numeric(p$atm[i]),
	       as.numeric(p$sig75[i]), as.numeric(p$sig90[i]))
	cubicspline(x, y, endp2nd = TRUE, der = c(0, 0))

	if(delta <= 0.1){
		vol <- cubicspline(x, y, 0.1, endp2nd = TRUE, der = c(0, 0))
		}
	if(delta >= 0.9){
		vol <- cubicspline(x, y, 0.9, endp2nd = TRUE, der = c(0, 0))
		}
	if(delta > 0.1 & delta < 0.9){
		vol <- cubicspline(x, y, delta, endp2nd = TRUE, der = c(0, 0))
		}		
	return(vol)

}

PlotDeltaSmile <- function(dtStart){
	x <- seq(0, 1, 0.01)
	y <- sapply(x, DeltaSmile, dtStart)
	plot(x, y, type = "l", col = "darkblue", xlab = "Call Î´", ylab = "Implied Volatility")
	points(0.1, DeltaSmile(0.1, dtStart), pch = 19, col = "darkblue")
	points(0.25, DeltaSmile(0.25, dtStart), pch = 19, col = "darkblue")
	points(0.5, DeltaSmile(0.5, dtStart), pch = 19, col = "darkblue")
	points(0.75, DeltaSmile(0.75, dtStart), pch = 19, col = "darkblue")
	points(0.9, DeltaSmile(0.9, dtStart), pch = 19, col = "darkblue")
}

dtStart <- index(p)[1] # set date to 17 November 2009
PlotDeltaSmile(dtStart)

{% endhighlight %}

{% fullwidth 'assets/deltaSmile.png' %}

Now we transform the volatility smile from delta-ivol space to X-ivol space, where X is the option's (call) price. We can plot this new volatility smile as a function of X using
the `PlotXSmile()` function: 

{% highlight r %}
XSmile <- function(z, dtStart){

	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	X. <- z

	sigma.SS <- function(sigma){
		call.delta <- GBSGreeks(Selection = "delta", TypeFlag = "c", S = S., X = X.,
	                    Time = 1/12, r = r./100, b = (r. - q.)/100, sigma = sigma/100)
		sigma.hat <- DeltaSmile(delta = call.delta, dtStart)/100                    
		return( (sigma.hat - sigma/100)^2 )
	}

	res <- optimize(sigma.SS, interval = c(0, 2*p$atm[i]))$minimum
	return(res)

}

GetXValues <- function(delta, dtStart){

	sigma <- DeltaSmile(delta, dtStart)
	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	K. <- as.numeric(p$F[i])
	x.SS <- function(X.){
		call.delta <- GBSGreeks(Selection = "delta", TypeFlag = "c", S = S., X = X.,
	                    Time = 1/12, r = r./100, b = (r. - q.)/100, sigma = sigma/100)
	    return( (delta - call.delta)^2 )                
	 }
	res <- optimize(x.SS, interval = c(0, 2*K.))$minimum
	return(res)
}

GetRange <- function(dtStart){
	i <- which(dtStart == index(p))
	K. <- as.numeric(p$F[i])
	res <- NULL
	vals <- c(GetXValues(0.1, dtStart)/K.-1, GetXValues(0.25, dtStart)/K.-1, GetXValues(0.5, dtStart)/K.-1,
				GetXValues(0.75, dtStart)/K.-1, GetXValues(0.9, dtStart)/K.-1)
	res$min <- min(min(vals)-0.05, -0.125)
	res$max <- max(max(vals)+0.05, 0.125)
	return(res)
}

PlotXSmile <- function(dtStart){
	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	K. <- as.numeric(p$F[i])

	xmin <- GetRange(dtStart)$min
	xmax <- GetRange(dtStart)$max
	xxx <- seq((xmin+1)*K., (xmax+1)*K., length.out = 500)
	sss <- sapply(xxx, XSmile, dtStart)

	plot(xxx/K. - 1, sss, type = "l", xlim = c(xmin, xmax), ylim = c(min(sss), max(sss)),
			col = "palevioletred", ylab = "Implied Volatility", xlab = "Moneyness")
	points(GetXValues(0.1, dtStart)/K.-1, XSmile(GetXValues(0.1, dtStart), dtStart), pch = 19, col = "palevioletred")
	points(GetXValues(0.25, dtStart)/K.-1, XSmile(GetXValues(0.25, dtStart), dtStart), pch = 19, col = "palevioletred")
	points(GetXValues(0.5, dtStart)/K.-1, XSmile(GetXValues(0.5, dtStart), dtStart), pch = 19, col = "palevioletred")
	points(GetXValues(0.75, dtStart)/K.-1, XSmile(GetXValues(0.75, dtStart), dtStart), pch = 19, col = "palevioletred")
	points(GetXValues(0.9, dtStart)/K.-1, XSmile(GetXValues(0.90, dtStart), dtStart), pch = 19, col = "palevioletred")
}

PlotXSmile(dtStart)

{% endhighlight %}

{% fullwidth 'assets/xsmile.png' %}

Now we translate the volatility smile into the call price function for the option via the `Premium()` function, and plot the option price using the `PlotPremiums()` function:

{% highlight r %}
Premium <- function(z, dtStart){

	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])

	Premium <- GBSCharacteristics(TypeFlag = "c", S = S., X = z,
                  Time = 1/12, r = r./100, b = (r. - q.)/100, sigma = XSmile(z, dtStart)/100)$premium
	return(Premium)
}


PlotPremiums <- function(dtStart){
	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	K. <- as.numeric(p$F[i])

	xmin <- GetRange(dtStart)$min
	xmax <- GetRange(dtStart)$max
	xxx <- seq((xmin+1)*K., (xmax+1)*K., length.out = 1000)
	sss <- sapply(xxx, Premium, dtStart)/K.
	plot(xxx/K. - 1, sss, type = "l", xlim = c(xmin, xmax), ylim = c(min(sss), max(sss)), col = "purple",
		xlab = "Moneyness", ylab = "Call Price")
	points(GetXValues(0.1, dtStart)/K.-1, Premium(GetXValues(0.1, dtStart), dtStart)/K., pch = 19, col = "purple")
	points(GetXValues(0.25, dtStart)/K.-1, Premium(GetXValues(0.25, dtStart), dtStart)/K., pch = 19, col = "purple")
	points(GetXValues(0.5, dtStart)/K.-1, Premium(GetXValues(0.5, dtStart), dtStart)/K., pch = 19, col = "purple")
	points(GetXValues(0.75, dtStart)/K.-1, Premium(GetXValues(0.75, dtStart), dtStart)/K., pch = 19, col = "purple")
	points(GetXValues(0.9, dtStart)/K.-1, Premium(GetXValues(0.90, dtStart), dtStart)/K., pch = 19, col = "purple")		
}

PlotPremiums(dtStart)

{% endhighlight %}

{% fullwidth 'assets/premium.png' %}

Finally, we can use the call pricing function to plot the risk-neutral CDF of the underlying, getting the value of the CDF at each strike price with the `XCDF()` function, and plotting the distribution using the `PlotCDF()` function:
{% highlight r %}

XCDF <- function(z, dtStart, dX = 0.005){
	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	K. <- as.numeric(p$F[i])
	X_plus <- z + (dX*K./2)
	X_minus <- z - (dX*K./2)
	cdf <- 1 + (exp(q./100*1/12)/(dX*K.))*(Premium(X_plus, dtStart) - Premium(X_minus, dtStart))
	if(cdf < 0){cdf <- 0}
	if(cdf > 1){cdf <- 1}
	return(cdf)
}


PlotCDF <- function(dtStart){
	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	K. <- as.numeric(p$F[i])

	xmin <- min(GetRange(dtStart)$min, -0.5)
	xmax <- max(GetRange(dtStart)$max, 0.5)
	xxx <- seq((xmin+1)*K., (xmax+1)*K., length.out = 1000)
	sss <- sapply(xxx, XCDF, dtStart)
	plot(xxx/K. - 1, sss, type = "l", xlim = c(xmin, xmax), ylim = c(0, 1),
		col = "springgreen", xlab = "Moneyness", ylab = "")
	points(GetXValues(0.1, dtStart)/K.-1, XCDF(GetXValues(0.1, dtStart), dtStart), pch = 19, col = "springgreen")
	points(GetXValues(0.25, dtStart)/K.-1, XCDF(GetXValues(0.25, dtStart), dtStart), pch = 19, col = "springgreen")
	points(GetXValues(0.5, dtStart)/K.-1, XCDF(GetXValues(0.5, dtStart), dtStart), pch = 19, col = "springgreen")
	points(GetXValues(0.75, dtStart)/K.-1, XCDF(GetXValues(0.75, dtStart), dtStart), pch = 19, col = "springgreen")
	points(GetXValues(0.9, dtStart)/K.-1, XCDF(GetXValues(0.90, dtStart), dtStart), pch = 19, col = "springgreen")
}

PlotCDF(dtStart)

{% endhighlight %}

{% fullwidth 'assets/rndcdf.png' %}

We can also build similar functions to back out and plot the values of the risk-neutral PDF:
{% highlight r %}
XPDF <- function(z, dtStart, dX = 0.005){
	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	K. <- as.numeric(p$F[i])
	X_plus <- z + dX*K.
	X_minus <- z - dX*K.
	pdf <- (exp(1/100*q.*1/12)/(dX*K.)^2)*(Premium(X_plus, dtStart) +
			Premium(X_minus, dtStart) - 2*Premium(z, dtStart))
	return(pdf)
}


PlotPDF <- function(dtStart){
	i <- which(dtStart == index(p))
	if(length(i) == 0){stop("Date not in data.frame")}
	S. <- as.numeric(p$S[i])
	r. <- as.numeric(p$r[i])
	q. <- as.numeric(p$q[i])
	K. <- as.numeric(p$F[i])

	xmin <- min(GetRange(dtStart)$min, -0.5)
	xmax <- max(GetRange(dtStart)$max, 0.5)
	xxx <- seq((xmin+1)*K., (xmax+1)*K., length.out = 500)
	sss <- sapply(xxx, XPDF, dtStart)
	plot(xxx/K. - 1, sss, type = "l", xlim = c(-0.5, 0.5), ylim = c(min(sss), max(sss)),
		col = "deepskyblue3", xlab = "Moneyness", ylab = "")
	points(GetXValues(0.1, dtStart)/K.-1, XPDF(GetXValues(0.1, dtStart), dtStart), pch = 19, col = color)
	points(GetXValues(0.25, dtStart)/K.-1, XPDF(GetXValues(0.25, dtStart), dtStart), pch = 19, col = color)
	points(GetXValues(0.5, dtStart)/K.-1, XPDF(GetXValues(0.5, dtStart), dtStart), pch = 19, col = color)
	points(GetXValues(0.75, dtStart)/K.-1, XPDF(GetXValues(0.75, dtStart), dtStart), pch = 19, col = color)
	points(GetXValues(0.9, dtStart)/K.-1, XPDF(GetXValues(0.90, dtStart), dtStart), pch = 19, col = color)
}



PlotPDF(dtStart)

{% endhighlight %}

{% fullwidth 'assets/rndpdf.png' %}
